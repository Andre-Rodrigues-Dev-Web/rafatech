[
  {
    "id": 1,
    "title": "Como Implementar Dark Mode em React com Context API",
    "excerpt": "Aprenda a criar um sistema de tema escuro/claro eficiente usando React Context API e localStorage para persistir a preferência do usuário.",
    "content": "Implementar um modo escuro em aplicações React se tornou uma funcionalidade essencial para melhorar a experiência do usuário. Neste artigo, vamos explorar como criar um sistema robusto de temas usando Context API.\n\n## Por que usar Context API?\n\nO Context API do React é perfeito para gerenciar estados globais como temas, pois permite que qualquer componente acesse e modifique o tema atual sem prop drilling.\n\n## Implementação Passo a Passo\n\n### 1. Criando o Context\n\nPrimeiro, criamos um contexto para gerenciar o estado do tema:\n\n```tsx\nimport React, { createContext, useContext, useState } from 'react'\n\ninterface ThemeContextType {\n  isDark: boolean\n  toggleTheme: () => void\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n```\n\n### 2. Provider Component\n\nO provider encapsula nossa aplicação e fornece o estado do tema:\n\n```tsx\nexport const ThemeProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [isDark, setIsDark] = useState(false)\n  \n  const toggleTheme = () => setIsDark(!isDark)\n  \n  return (\n    <ThemeContext.Provider value={{ isDark, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n```\n\n### 3. Hook Personalizado\n\nCriamos um hook para facilitar o uso do contexto:\n\n```tsx\nexport const useTheme = () => {\n  const context = useContext(ThemeContext)\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider')\n  }\n  return context\n}\n```\n\n## Persistindo a Preferência\n\nPara manter a preferência do usuário entre sessões, utilizamos localStorage:\n\n```tsx\nconst [isDark, setIsDark] = useState(() => {\n  const saved = localStorage.getItem('theme')\n  return saved ? JSON.parse(saved) : false\n})\n\nuseEffect(() => {\n  localStorage.setItem('theme', JSON.stringify(isDark))\n}, [isDark])\n```\n\n## Conclusão\n\nImplementar dark mode com Context API é uma solução elegante e escalável. Esta abordagem garante consistência em toda a aplicação e oferece uma excelente experiência do usuário.",
    "author": "Rafaela Rodrigues",
    "date": "2024-01-15",
    "readTime": "5 min",
    "tags": ["React", "Context API", "Dark Mode", "UX"],
    "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
  },
  {
    "id": 2,
    "title": "TypeScript: Tipos Avançados para Desenvolvedores React",
    "excerpt": "Explore tipos avançados do TypeScript que podem melhorar significativamente a qualidade e manutenibilidade do seu código React.",
    "content": "TypeScript oferece um sistema de tipos poderoso que vai muito além dos tipos básicos. Neste artigo, exploraremos tipos avançados que podem revolucionar seu desenvolvimento React.\n\n## Utility Types Essenciais\n\n### Partial<T>\n\nO tipo `Partial<T>` torna todas as propriedades de um tipo opcionais:\n\n```tsx\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\n// Todas as propriedades são opcionais\ntype PartialUser = Partial<User>\n\nconst updateUser = (user: PartialUser) => {\n  // Pode receber apenas algumas propriedades\n}\n```\n\n### Pick<T, K>\n\nSeleciona apenas propriedades específicas de um tipo:\n\n```tsx\ntype UserPreview = Pick<User, 'id' | 'name'>\n// Resultado: { id: number; name: string }\n```\n\n### Omit<T, K>\n\nExclui propriedades específicas de um tipo:\n\n```tsx\ntype CreateUser = Omit<User, 'id'>\n// Resultado: { name: string; email: string }\n```\n\n## Tipos Condicionais\n\nOs tipos condicionais permitem criar tipos que dependem de condições:\n\n```tsx\ntype ApiResponse<T> = T extends string \n  ? { message: T } \n  : { data: T }\n\ntype StringResponse = ApiResponse<string> // { message: string }\ntype UserResponse = ApiResponse<User> // { data: User }\n```\n\n## Mapped Types\n\nCrie novos tipos baseados em tipos existentes:\n\n```tsx\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype ReadonlyUser = Readonly<User>\n// Todas as propriedades são readonly\n```\n\n## Template Literal Types\n\nCombine strings de forma type-safe:\n\n```tsx\ntype EventName = 'click' | 'focus' | 'blur'\ntype EventHandler<T extends EventName> = `on${Capitalize<T>}`\n\ntype ClickHandler = EventHandler<'click'> // 'onClick'\n```\n\n## Aplicação Prática em React\n\n### Props com Discriminated Unions\n\n```tsx\ntype ButtonProps = \n  | { variant: 'primary'; color?: never }\n  | { variant: 'secondary'; color: 'blue' | 'red' }\n\nconst Button: React.FC<ButtonProps> = ({ variant, color }) => {\n  // TypeScript garante que color só existe quando variant é 'secondary'\n}\n```\n\n### Generic Components\n\n```tsx\ninterface ListProps<T> {\n  items: T[]\n  renderItem: (item: T) => React.ReactNode\n  keyExtractor: (item: T) => string | number\n}\n\nconst List = <T,>({ items, renderItem, keyExtractor }: ListProps<T>) => {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item)}\n        </li>\n      ))}\n    </ul>\n  )\n}\n```\n\n## Conclusão\n\nDominar tipos avançados do TypeScript é fundamental para criar aplicações React robustas e maintíveis. Estes conceitos ajudam a prevenir bugs e melhoram a experiência de desenvolvimento.",
    "author": "Rafaela Rodrigues",
    "date": "2024-01-10",
    "readTime": "8 min",
    "tags": ["TypeScript", "React", "Tipos Avançados", "Desenvolvimento"],
    "image": "https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=800&h=400&fit=crop"
  },
  {
    "id": 3,
    "title": "Performance em React: Otimizações Essenciais",
    "excerpt": "Descubra técnicas avançadas de otimização para melhorar significativamente a performance de suas aplicações React.",
    "content": "A performance é crucial para o sucesso de qualquer aplicação web. Neste artigo, exploraremos técnicas avançadas para otimizar aplicações React.\n\n## React.memo e Memoização\n\n### React.memo\n\nEvita re-renderizações desnecessárias de componentes funcionais:\n\n```tsx\nconst ExpensiveComponent = React.memo(({ data }) => {\n  return (\n    <div>\n      {/* Renderização custosa */}\n    </div>\n  )\n})\n```\n\n### useMemo\n\nMemoiza cálculos custosos:\n\n```tsx\nconst Component = ({ items }) => {\n  const expensiveValue = useMemo(() => {\n    return items.reduce((acc, item) => acc + item.value, 0)\n  }, [items])\n  \n  return <div>{expensiveValue}</div>\n}\n```\n\n### useCallback\n\nMemoiza funções para evitar re-criações:\n\n```tsx\nconst Parent = ({ items }) => {\n  const handleClick = useCallback((id) => {\n    // Lógica do click\n  }, [])\n  \n  return (\n    <div>\n      {items.map(item => (\n        <Child key={item.id} onClick={handleClick} />\n      ))}\n    </div>\n  )\n}\n```\n\n## Virtualização de Listas\n\nPara listas grandes, use bibliotecas como react-window:\n\n```tsx\nimport { FixedSizeList as List } from 'react-window'\n\nconst VirtualizedList = ({ items }) => {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  )\n  \n  return (\n    <List\n      height={600}\n      itemCount={items.length}\n      itemSize={50}\n    >\n      {Row}\n    </List>\n  )\n}\n```\n\n## Code Splitting\n\n### Lazy Loading de Componentes\n\n```tsx\nconst LazyComponent = React.lazy(() => import('./HeavyComponent'))\n\nconst App = () => {\n  return (\n    <Suspense fallback={<div>Carregando...</div>}>\n      <LazyComponent />\n    </Suspense>\n  )\n}\n```\n\n### Route-based Code Splitting\n\n```tsx\nconst Home = React.lazy(() => import('./pages/Home'))\nconst About = React.lazy(() => import('./pages/About'))\n\nconst App = () => {\n  return (\n    <Router>\n      <Suspense fallback={<div>Carregando...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  )\n}\n```\n\n## Otimização de Bundle\n\n### Tree Shaking\n\nImporte apenas o que você precisa:\n\n```tsx\n// ❌ Importa toda a biblioteca\nimport _ from 'lodash'\n\n// ✅ Importa apenas a função necessária\nimport debounce from 'lodash/debounce'\n```\n\n### Webpack Bundle Analyzer\n\nAnalise o tamanho do seu bundle:\n\n```bash\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n## Profiling e Debugging\n\n### React DevTools Profiler\n\nUse o Profiler para identificar componentes lentos:\n\n```tsx\nimport { Profiler } from 'react'\n\nconst onRenderCallback = (id, phase, actualDuration) => {\n  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration)\n}\n\nconst App = () => {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <MyComponent />\n    </Profiler>\n  )\n}\n```\n\n## Conclusão\n\nA otimização de performance é um processo contínuo. Use essas técnicas de forma estratégica, sempre medindo o impacto real na experiência do usuário.",
    "author": "Rafaela Rodrigues",
    "date": "2024-01-05",
    "readTime": "10 min",
    "tags": ["React", "Performance", "Otimização", "Web Development"],
    "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
  }
]